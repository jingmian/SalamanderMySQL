# MySQL锁概述

MySQL 两种锁特性归纳：  
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。  
MySQL 不同的存储引擎支持不同的锁机制。  
MyISAM 和 memory 存储引擎采用的是**表级锁**  
InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下采用**行级锁**。注意**InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁**  
表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 web 应用。  
而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。

# MyISAM的锁

1. MyISAM的表级锁模式
MySQL 的表级锁有两种模式，表共享读锁(table read lock)和表独占写锁（table write lock）。  
对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM  表的读操作和写操作之间，以及写操作之间时串行的。  
当一个线程获得对一个表的写锁户，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放。

2. 加锁
MyISAM 在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert等）前，会自动给涉及的表加**写锁**，这个过程并不需要直接用 lock table 命令给 MyISAM 表显示加锁。给 MyISAM 表显式加锁，一般是为了在一定程度模拟事务操作 
MyISAM 在自动加锁的情况下，总是一次获得 sql 语句所需要的全部锁，所以显示锁表的时候，必须同时取得所有涉及表的锁，这也正是 MyISAM 表不会出现死锁（deadlock）的原因。

3. 并发插入（concurrent inserts）
MyISAM 表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM 表也支持查询和插入操作的并发进行。  
MyISAM 存储引擎有一个系统变量 concurrent_insert , 专门用以控制其并发插入的行为，其值分别可以为0,1,2。  
当 concurrent_insert 设置为 0 时，不允许并发插入。  
当 concurrent_insert 设置为 1 时，如果 MyISAM 表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是 MySQL 的默认设置。  
当 concurrent_insert 设置为 2 时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。

4. MyISAM 的锁调度
MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。当一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁时，**写进程会先获得锁**。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前，这是因为 mysql 认为写请求一般比读请求重要。这也正是 **MyISAM 表不太适合有大量更新操作和查询操作应用**的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。  
通过一些参数设置可以调节 MySQL 的默认调度行为：  
*  通过指定启动参数 low-priority-updates, 使 myisam 引擎默认给予读请求以优先的权利。
*  通过执行命令 set low_priority_updates = 1, 使该连接发出的更新请求优先级降低。
*  通过指定 insert、update、delete 语句的 low_priority 属性，降低该语句的优先级。
上述方式都是要么更新优先，要么查询优先，MySQL 也提供了一种折中的办法调节读写冲突:  
给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。


# InnoDB锁
InnoDB 与 MyISAM 的最大不同有两点，一是支持事务（transaction），二是采用了行级锁。  
1. 并发事务处理存在的问题  
相对于串行处理来说，并发事务处理能力大大增加数据库资源的利用率，提高数据库系统事务吞吐量，从而可以支持更多的用户，但并发事务处理也会带来一些问题：  
**更新丢失（lost update）**  
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。  
**脏读（dirty reads）**  
一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。  
**不可重复读（non-repeatable reads）**  
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除了！这种现象就是“不可重复读”。  
**幻读（phantom reads）**  
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象称为“幻读”。

2. 事务隔离级别
数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92 定义了 4 个事务隔离级别，MySQL 实现了这四种级别，应用可以根据自己的业务逻辑要求，选择合适的隔离级别来平衡“隔离”与“并发”的矛盾。MySQL的默认隔离级别为repeatable read（RR），另外MySQL通过MVCC避免幻读  

| 隔离级别  | 脏读  | 不可重复读 |  幻读 |
| :------------ |:---------------:| -----:| -----:|
| Read  uncommitted | √    | √ | √ |
| Read committed    | ×    | √ | √ |
| Repeatable read   | ×    | × | √ |
| Serializable      |  ×   | × | × |

3. 查看 Innodb 行锁争用情况
可以通过检查 innodb_row_lock 状态变量来分析系统上的行锁的争夺情况：
```
mysql> show status like 'innodb_row_lock%';
+-------------------------------+--------+
| Variable_name                 | Value  |
+-------------------------------+--------+
| Innodb_row_lock_current_waits | 0      |
| Innodb_row_lock_time          | 348119 |
| Innodb_row_lock_time_avg      | 212    |
| Innodb_row_lock_time_max      | 51010  |
| Innodb_row_lock_waits         | 1638   |
+-------------------------------+--------+
5 rows in set (0.01 sec)
```

4. InnoDB 的行锁模式及加锁方法
Innodb 实现了两种类型的行锁：

* 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
* 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获取相同数据集的共享读锁和排他写锁。
另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁，这两种意向锁都是**表锁**：

* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
* 意向排它锁（IX）: 事务打算给数据行加行排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。  

| ****  | 共享锁（S）  | 排他锁（X） | 意向共享锁（IS） | 意向排他锁（IX） |  
| :------- |:-------------:| -----:| -----:| -----:|
| 共享锁（S）      | 兼容 | 冲突 | 兼容 | 冲突 |
| 排他锁（X）      | 冲突 | 冲突 | 冲突 | 冲突 |
| 意向共享锁（IS） | 兼容 | 冲突 | 兼容 | 兼容 |
| 意向排他锁（IX） | 冲突 | 冲突 | 兼容 | 兼容 |

如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。 
意向锁是 InnoDB 自动加的，不需要用户干预。对于 update、delete 和 insert 语句，InnoDB 会自动给涉及数据集加排它锁（X）；**对于普通 select 语句，InnoDB 不会加任何锁**。

事务可以通过以下语句显式给记录集加共享锁或排它锁。

* 共享锁（S）：select * from table_name where ... lock in share mode.
* 排它锁（X）: select * from table_name where ... for update.
用 select... in share mode 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 update 或者 delete 操作。但是如果当前事务也需要对该记录进行更新操作,则有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 select... for update 方式获得排他锁。

5. InnoDB 行锁实现方式
innodb 行锁是通过给索引项加锁来实现的，如果么有索引，innodb 将通过隐藏的聚簇索引来对记录加锁。innodb 行锁分为 3 种情形：

* record lock： 对索引项加锁
* gap lock： 对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录的“间隙”加锁。
* next-key lock： 前两种的结合，对记录及其前面的间隙加锁。
**innodb 这种行锁实现特点意味着：如果不通过索引条件检索数据，那么 innodb 将对表中的所有记录加锁，实际效果和表锁一样！**  

在实际应用中，要特别注意 InnoDB 行锁的这一特性，否则可能导致大量的锁冲突，从而影响并发性能。



6. next-key 锁
当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时,innodb 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（gap）”，innodb 也会对这个“间隙”加锁，这种锁机制就是所谓的 next-key 锁。

举例来说，假如 emp 表中只有 101 条记录，其 id 的值分别是1、2、...、100、101，下面的 sql:
```
# 这是一个范围条件的检索，innodb 不仅会对符合条件的 id 值为 101 的记录加锁，也会对 id 大于 101（这些记录并不存在）的“间隙”加锁。
select * from emp where id > 100 for update;
为什么使用 next-key 锁
```
InnoDB 使用 next-key 锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 id 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。  
在使用范围条件检索并锁定记录时，InnoDB 这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，应该尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。  
InnoDB 除了通过范围条件加锁时使用 next-key 锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用 next-key 锁
