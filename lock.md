# MySQL锁概述

MySQL 两种锁特性归纳：  
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。  
MySQL 不同的存储引擎支持不同的锁机制。  
MyISAM 和 memory 存储引擎采用的是**表级锁**  
InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下采用**行级锁**。  

表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 web 应用。  
而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。

# MyISAM的锁

1. MyISAM的表级锁模式
MySQL 的表级锁有两种模式，表共享读锁(table read lock)和表独占写锁（table write lock）。  
对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM  表的读操作和写操作之间，以及写操作之间时串行的。  
当一个线程获得对一个表的写锁户，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放。

2. 加锁
MyISAM 在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert等）前，会自动给涉及的表加**写锁**，这个过程并不需要直接用 lock table 命令给 MyISAM 表显示加锁。给 MyISAM 表显式加锁，一般是为了在一定程度模拟事务操作 
MyISAM 在自动加锁的情况下，总是一次获得 sql 语句所需要的全部锁，所以显示锁表的时候，必须同时取得所有涉及表的锁，这也正是 MyISAM 表不会出现死锁（deadlock）的原因。

3. 并发插入（concurrent inserts）
MyISAM 表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM 表也支持查询和插入操作的并发进行。  
MyISAM 存储引擎有一个系统变量 concurrent_insert , 专门用以控制其并发插入的行为，其值分别可以为0,1,2。  
当 concurrent_insert 设置为 0 时，不允许并发插入。  
当 concurrent_insert 设置为 1 时，如果 MyISAM 表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是 MySQL 的默认设置。  
当 concurrent_insert 设置为 2 时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。

4. MyISAM 的锁调度
MyISAM 存储引擎的读锁和写锁是互斥的，读写操作时串行的。当一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁时，**写进程会先获得锁**。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前，这是因为 mysql 认为写请求一般比读请求重要。这也正是 **MyISAM 表不太适合有大量更新操作和查询操作应用**的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。  
通过一些参数设置可以调节 MySQL 的默认调度行为：  
*  通过指定启动参数 low-priority-updates, 使 myisam 引擎默认给予读请求以优先的权利。
*  通过执行命令 set low_priority_updates = 1, 使该连接发出的更新请求优先级降低。
*  通过指定 insert、update、delete 语句的 low_priority 属性，降低该语句的优先级。
上述方式都是要么更新优先，要么查询优先，MySQL 也提供了一种折中的办法调节读写冲突:  
给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。


# InnoDB锁
InnoDB 与 MyISAM 的最大不同有两点，一是支持事务（transaction），二是采用了行级锁。  
1. 并发事务处理存在的问题  
相对于串行处理来说，并发事务处理能力大大增加数据库资源的利用率，提高数据库系统事务吞吐量，从而可以支持更多的用户，但并发事务处理也会带来一些问题：  
**更新丢失（lost update）**  
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。  
**脏读（dirty reads）**  
一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。  
**不可重复读（non-repeatable reads）**  
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除了！这种现象就是“不可重复读”。  
**幻读（phantom reads）**  
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象称为“幻读”。


