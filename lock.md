# MySQL锁概述

MySQL 两种锁特性归纳：  
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。  
MySQL 不同的存储引擎支持不同的锁机制。  
MyISAM 和 memory 存储引擎采用的是**表级锁**  
InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下采用**行级锁**。  

表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 web 应用。  
而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。

# MyISAM的锁

1. MyISAM的表级锁模式
MySQL 的表级锁有两种模式，表共享读锁(table read lock)和表独占写锁（table write lock）。  
对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM  表的读操作和写操作之间，以及写操作之间时串行的。  
当一个线程获得对一个表的写锁户，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放。

2. 加锁
MyISAM 在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert等）前，会自动给涉及的表加**写锁**，这个过程并不需要直接用 lock table 命令给 MyISAM 表显示加锁。给 MyISAM 表显式加锁，一般是为了在一定程度模拟事务操作 
MyISAM 在自动加锁的情况下，总是一次获得 sql 语句所需要的全部锁，所以显示锁表的时候，必须同时取得所有涉及表的锁，这也正是 MyISAM 表不会出现死锁（deadlock）的原因。

3. 并发插入（concurrent inserts）
MyISAM 表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM 表也支持查询和插入操作的并发进行。  
MyISAM 存储引擎有一个系统变量 concurrent_insert , 专门用以控制其并发插入的行为，其值分别可以为0,1,2。  
当 concurrent_insert 设置为 0 时，不允许并发插入。  
当 concurrent_insert 设置为 1 时，如果 MyISAM 表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是 MySQL 的默认设置。  
当 concurrent_insert 设置为 2 时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。

4. MyISAM 的锁调度
MyISAM 存储引擎的读锁和写锁是互斥的，读写操作时串行的。当一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁时，**写进程会先获得锁**。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前，这是因为 mysql 认为写请求一般比读请求重要。这也正是 MyISAM 表不太适合有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。